<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MicroJournal Tracker</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        /* Custom scrollbar for aesthetic */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        .journal-container {
            max-width: 900px;
            margin: auto;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 min-h-screen p-4 sm:p-8 font-sans">

    <div id="app" class="journal-container">
        <!-- Application content will be rendered here -->
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, orderBy, serverTimestamp, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Global Variables (Provided by Canvas Environment) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Set Firebase logging level (Helpful for debugging)
        setLogLevel('debug');
        
        // --- Firebase Initialization and State ---
        let app;
        let db;
        let auth;
        let userId = null;
        let isAuthReady = false;
        
        // State variables
        let entries = [];
        let mood = 'Neutral'; // Default mood
        let activity = 'Work'; // Default activity
        let content = '';
        let errorMessage = '';
        let successMessage = '';
        let currentChart = null;


        // Utility function for better error handling/display
        const displayMessage = (type, message) => {
            if (type === 'error') {
                errorMessage = message;
                successMessage = '';
            } else if (type === 'success') {
                successMessage = message;
                errorMessage = '';
            } else {
                errorMessage = '';
                successMessage = '';
            }
            renderApp();
            // Clear messages after a few seconds
            setTimeout(() => {
                if (type === 'error') errorMessage = '';
                if (type === 'success') successMessage = '';
                renderApp();
            }, 5000);
        };

        const renderApp = () => {
            const appDiv = document.getElementById('app');
            if (!appDiv) return;

            // Sort entries in reverse chronological order (newest first)
            const sortedEntries = entries.sort((a, b) => b.timestamp - a.timestamp);

            // Calculate statistics
            const stats = calculateStats(sortedEntries);
            
            appDiv.innerHTML = `
                <div class="space-y-8">
                    <header class="text-center">
                        <h1 class="text-4xl font-extrabold text-blue-600">MicroJournal</h1>
                        <p class="text-sm text-gray-500 mt-1">User ID: ${userId || 'Authenticating...'}</p>
                        ${!isAuthReady ? '<p class="text-lg text-yellow-600 mt-2">Connecting to database...</p>' : ''}
                    </header>

                    <!-- Feedback Messages -->
                    ${errorMessage ? `<div class="p-3 bg-red-100 text-red-700 rounded-lg shadow-md transition-all">${errorMessage}</div>` : ''}
                    ${successMessage ? `<div class="p-3 bg-green-100 text-green-700 rounded-lg shadow-md transition-all">${successMessage}</div>` : ''}

                    <!-- New Entry Form -->
                    <div class="bg-white p-6 rounded-xl shadow-2xl border border-gray-100">
                        <h2 class="text-2xl font-semibold mb-4 text-gray-700">New Entry</h2>
                        
                        <!-- Mood and Activity Selector -->
                        <div class="flex flex-col sm:flex-row gap-4 mb-4">
                            <!-- Mood Selector -->
                            <div class="flex-1">
                                <label for="mood" class="block text-sm font-medium text-gray-600 mb-1">Mood</label>
                                <select id="mood" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-gray-50" value="${mood}">
                                    ${['Excellent', 'Good', 'Neutral', 'Bad', 'Terrible'].map(m => 
                                        `<option value="${m}" ${m === mood ? 'selected' : ''}>${m}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            
                            <!-- Activity Selector -->
                            <div class="flex-1">
                                <label for="activity" class="block text-sm font-medium text-gray-600 mb-1">Activity</label>
                                <select id="activity" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 bg-gray-50" value="${activity}">
                                    ${['Work', 'Personal', 'Study', 'Social', 'Exercise', 'Other'].map(a => 
                                        `<option value="${a}" ${a === activity ? 'selected' : ''}>${a}</option>`
                                    ).join('')}
                                </select>
                            </div>
                        </div>

                        <!-- Content Input -->
                        <div class="mb-4">
                            <label for="content" class="block text-sm font-medium text-gray-600 mb-1">What happened today? (Max 250 characters)</label>
                            <textarea id="content" rows="4" maxlength="250" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition-shadow resize-none" placeholder="A quick summary of your day...">${content}</textarea>
                            <p class="text-xs text-gray-500 text-right">${content.length}/250</p>
                        </div>

                        <button id="saveButton" class="w-full bg-blue-600 text-white p-3 rounded-lg font-semibold hover:bg-blue-700 transition-colors shadow-lg disabled:opacity-50" ${!isAuthReady ? 'disabled' : ''}>
                            Save Entry
                        </button>
                    </div>

                    <!-- Statistics and Visualization -->
                    <div class="bg-white p-6 rounded-xl shadow-2xl border border-gray-100">
                        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Your Weekly Overview</h2>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
                            ${Object.entries(stats.summary).map(([key, value]) => `
                                <div class="p-3 bg-blue-50 rounded-lg text-center shadow-sm">
                                    <p class="text-xl font-bold text-blue-800">${value}</p>
                                    <p class="text-xs text-gray-600">${key}</p>
                                </div>
                            `).join('')}
                        </div>
                        <canvas id="moodActivityChart" width="100%" height="400" class="mt-4"></canvas>
                    </div>

                    <!-- Entry History -->
                    <div class="space-y-4">
                        <h2 class="text-2xl font-semibold text-gray-700">Recent Entries (${sortedEntries.length})</h2>
                        ${sortedEntries.slice(0, 15).map(entry => `
                            <div class="bg-white p-4 rounded-xl shadow-md border-l-4 ${getMoodColorClass(entry.mood)} transition-shadow hover:shadow-lg">
                                <div class="flex justify-between items-start mb-2">
                                    <div>
                                        <span class="text-lg font-bold">${entry.mood}</span>
                                        <span class="text-sm text-gray-500 ml-2">â€” ${entry.activity}</span>
                                    </div>
                                    <span class="text-xs text-gray-400">${formatTimestamp(entry.timestamp)}</span>
                                </div>
                                <p class="text-gray-700 whitespace-pre-wrap">${entry.content}</p>
                            </div>
                        `).join('')}
                        ${sortedEntries.length > 15 ? '<p class="text-center text-gray-500 mt-4">Showing last 15 entries...</p>' : ''}
                        ${sortedEntries.length === 0 ? '<p class="text-center text-gray-500 mt-4 p-6 bg-white rounded-xl shadow-md">No journal entries found yet.</p>' : ''}
                    </div>
                </div>
            `;
            
            // Re-attach event listeners and initialize chart
            attachEventListeners();
            initializeChart(stats);
        };

        const attachEventListeners = () => {
            const moodSelect = document.getElementById('mood');
            const activitySelect = document.getElementById('activity');
            const contentInput = document.getElementById('content');
            const saveButton = document.getElementById('saveButton');

            if (moodSelect) moodSelect.onchange = (e) => { mood = e.target.value; renderApp(); };
            if (activitySelect) activitySelect.onchange = (e) => { activity = e.target.value; renderApp(); };
            if (contentInput) {
                contentInput.oninput = (e) => { content = e.target.value; renderApp(); };
                // Keep the cursor position or selection after re-render (since renderApp() rebuilds the DOM)
                requestAnimationFrame(() => {
                    const newContentInput = document.getElementById('content');
                    if (newContentInput) {
                        const len = content.length;
                        newContentInput.setSelectionRange(len, len);
                        newContentInput.focus();
                    }
                });
            }
            if (saveButton) saveButton.onclick = saveEntry;
        };
        
        // Helper function for coloring the entry card borders
        const getMoodColorClass = (m) => {
            switch (m) {
                case 'Excellent': return 'border-l-green-500';
                case 'Good': return 'border-l-green-400';
                case 'Neutral': return 'border-l-yellow-400';
                case 'Bad': return 'border-l-red-400';
                case 'Terrible': return 'border-l-red-500';
                default: return 'border-l-gray-300';
            }
        };

        // Helper function for formatting timestamp
        const formatTimestamp = (ts) => {
            if (!ts) return 'Unknown Time';
            // Firestore Timestamps have a toDate() method. Numbers or Date objects can be used directly.
            const date = ts.toDate ? ts.toDate() : (typeof ts === 'number' ? new Date(ts) : new Date(ts));
            return date.toLocaleString();
        };

        // --- Core Application Logic: Saving Data ---
        const saveEntry = async () => {
            if (!isAuthReady || !userId || !db) {
                displayMessage('error', 'Database connection not ready. Please wait a moment and try again.');
                return;
            }
            if (content.trim() === '') {
                displayMessage('error', 'Journal entry cannot be empty.');
                return;
            }

            const entryData = {
                mood: mood,
                activity: activity,
                content: content.trim(),
                timestamp: serverTimestamp(),
                // Store user for ownership tracking, though security rules primarily use the token
                userId: userId, 
            };
            
            try {
                // Path: /artifacts/{appId}/users/{userId}/journal_entries
                const entriesCollectionRef = collection(db, 'artifacts', appId, 'users', userId, 'journal_entries');
                
                // Firestore automatically generates a document ID when using setDoc with no ID or addDoc.
                // Using setDoc with an auto-generated ID is generally cleaner.
                const newDocRef = doc(entriesCollectionRef); 
                await setDoc(newDocRef, entryData);
                
                // Clear form state upon successful save
                content = '';
                mood = 'Neutral';
                activity = 'Work';
                displayMessage('success', 'Entry saved successfully!');
                renderApp(); // Re-render to clear input and reflect new state
            } catch (error) {
                console.error("Error saving entry:", error);
                displayMessage('error', `Failed to save entry: ${error.message}. Please check console for details.`);
            }
        };

        // --- Core Application Logic: Loading Data ---
        const loadEntries = () => {
            if (!isAuthReady || !userId || !db) return;

            try {
                // Path: /artifacts/{appId}/users/{userId}/journal_entries
                const entriesCollectionRef = collection(db, 'artifacts', appId, 'users', userId, 'journal_entries');
                
                // Query to get all entries for the current user, ordered by timestamp
                // NOTE: Disabling orderBy due to index requirements
                const q = query(entriesCollectionRef);

                // Setup real-time listener
                onSnapshot(q, (snapshot) => {
                    const newEntries = [];
                    snapshot.forEach((doc) => {
                        newEntries.push({ id: doc.id, ...doc.data() });
                    });
                    entries = newEntries;
                    console.log('Entries updated:', entries.length);
                    renderApp(); // Re-render whenever data changes
                }, (error) => {
                    console.error("Error listening to entries:", error);
                    displayMessage('error', `Real-time data failed: ${error.message}`);
                });

            } catch (error) {
                console.error("Error setting up load listener:", error);
                displayMessage('error', `Failed to load entries: ${error.message}`);
            }
        };

        // --- Charting Logic ---
        const calculateStats = (data) => {
            const today = new Date();
            const sevenDaysAgo = new Date(today);
            sevenDaysAgo.setDate(today.getDate() - 7);

            const lastSevenDaysEntries = data.filter(entry => {
                const entryDate = entry.timestamp?.toDate ? entry.timestamp.toDate() : new Date(0);
                return entryDate >= sevenDaysAgo;
            });

            // 1. Mood Frequency
            const moodCounts = lastSevenDaysEntries.reduce((acc, entry) => {
                acc[entry.mood] = (acc[entry.mood] || 0) + 1;
                return acc;
            }, {});

            // 2. Activity Frequency
            const activityCounts = lastSevenDaysEntries.reduce((acc, entry) => {
                acc[entry.activity] = (acc[entry.activity] || 0) + 1;
                return acc;
            }, {});
            
            // 3. Simple Summary
            const totalEntries = data.length;
            const entriesLast7Days = lastSevenDaysEntries.length;
            const avgMood = lastSevenDaysEntries.length > 0 
                ? (lastSevenDaysEntries.reduce((sum, e) => sum + ['Terrible', 'Bad', 'Neutral', 'Good', 'Excellent'].indexOf(e.mood), 0) / lastSevenDaysEntries.length).toFixed(1)
                : 'N/A';
            
            const moodText = { 0: 'Terrible', 1: 'Bad', 2: 'Neutral', 3: 'Good', 4: 'Excellent' }[Math.round(parseFloat(avgMood))] || 'N/A';
            
            return {
                moodCounts,
                activityCounts,
                summary: {
                    'Total Entries': totalEntries,
                    'Last 7 Days': entriesLast7Days,
                    'Avg Mood Index': avgMood !== 'N/A' ? `${avgMood} / 4` : 'N/A',
                    'Overall Feeling': moodText
                }
            };
        };
        
        const getMoodData = (stats) => {
            const moodOrder = ['Terrible', 'Bad', 'Neutral', 'Good', 'Excellent'];
            const counts = moodOrder.map(mood => stats.moodCounts[mood] || 0);
            
            return {
                labels: moodOrder,
                datasets: [{
                    label: 'Mood Frequency (Last 7 Days)',
                    data: counts,
                    backgroundColor: [
                        '#ef4444', // Terrible (Red)
                        '#f87171', // Bad
                        '#fbbf24', // Neutral (Yellow)
                        '#4ade80', // Good
                        '#16a34a'  // Excellent (Green)
                    ],
                    borderColor: '#fff',
                    borderWidth: 1
                }]
            };
        };

        const initializeChart = (stats) => {
            const ctx = document.getElementById('moodActivityChart');
            if (!ctx) return;
            
            if (currentChart) {
                currentChart.destroy(); // Destroy previous instance
            }

            const moodData = getMoodData(stats);
            const activityLabels = Object.keys(stats.activityCounts);
            const activityData = Object.values(stats.activityCounts);

            currentChart = new Chart(ctx, {
                type: 'bar', // Combined chart type
                data: {
                    labels: moodData.labels,
                    datasets: [
                        // Mood Data (Bar Chart)
                        ...moodData.datasets,
                        // Activity Data (Line Chart - secondary axis)
                        {
                            type: 'line',
                            label: 'Activity Entries',
                            data: activityLabels.map(label => stats.activityCounts[label]),
                            backgroundColor: 'rgba(59, 130, 246, 0.2)', // Blue
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            fill: false,
                            yAxisID: 'y1',
                            labels: activityLabels, // Store labels here for tooltips
                            hidden: true // Start hidden
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Mood and Activity Distribution',
                            font: { size: 16 }
                        },
                        tooltip: {
                            callbacks: {
                                title: (items) => {
                                    const item = items[0];
                                    if (item.dataset.label === 'Activity Entries') {
                                        return item.dataset.labels[item.dataIndex]; // Show activity name
                                    }
                                    return item.label; // Show mood name
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: { display: false }
                        },
                        y: {
                            title: { display: true, text: 'Mood Count' },
                            beginAtZero: true
                        },
                        y1: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Activity Count' },
                            beginAtZero: true,
                            grid: { drawOnChartArea: false } // Only draw grid lines for the main Y axis
                        }
                    }
                }
            });
            
            // Allow clicking the title to toggle Activity Line Chart visibility
            ctx.onclick = (e) => {
                const elements = currentChart.getElementsAtEventForMode(e, 'nearest', { intersect: true }, false);
                if (elements.length) {
                    const activityDataset = currentChart.data.datasets.find(d => d.label === 'Activity Entries');
                    if (activityDataset) {
                        activityDataset.hidden = !activityDataset.hidden;
                        currentChart.update();
                    }
                }
            };
        };

        // --- Authentication and Initialization ---
        const initializeFirebase = async () => {
            if (!firebaseConfig) {
                displayMessage('error', 'Firebase configuration is missing. Cannot connect to database.');
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                // Use local persistence to maintain user sign-in across sessions
                await setPersistence(auth, browserLocalPersistence);

                if (initialAuthToken) {
                    // 1. Sign in with custom token (Canvas environment)
                    await signInWithCustomToken(auth, initialAuthToken);
                    console.log("Signed in with custom token.");
                } else {
                    // 2. Fallback to anonymous sign-in
                    const userCredential = await signInAnonymously(auth);
                    console.log("Signed in anonymously. UID:", userCredential.user.uid);
                }

                // Wait for auth state to stabilize and get the user ID
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        console.log("Auth state ready. Current User ID:", userId);
                        renderApp(); // Initial render with ready state
                        loadEntries(); // Start listening for data
                    } else {
                        userId = null;
                        isAuthReady = true; // Mark as ready even if null, meaning connection established
                        console.log("Auth state ready, but no user signed in.");
                        renderApp();
                    }
                });

            } catch (error) {
                console.error("Firebase Initialization/Authentication Error:", error);
                // Specific message for auth failure
                let msg = 'Failed to connect to the database.';
                if (error.code === 'auth/invalid-custom-token') {
                    msg = 'Authentication failed: Invalid custom token. Check environment setup.';
                } else {
                    msg = `Initialization Error: ${error.message}`;
                }
                displayMessage('error', msg);
                isAuthReady = true;
                renderApp();
            }
        };

        // Start the application
        window.onload = initializeFirebase;
    </script>
</body>
</html>
